// Copyright (C) 2023-2024 The Software Heritage developers
// See the AUTHORS file at the top-level directory of this distribution
// License: GNU General Public License version 3, or any later version
// See top-level LICENSE file for more information

//! Helpers for the `ar_row_derive` crate.

#![allow(clippy::redundant_closure_call)]

use std::sync::Arc;

use arrow::array::*;
use arrow::datatypes::*;
//use rust_decimal::Decimal;
use thiserror::Error;

use std::iter::Map;
use std::num::TryFromIntError;
use std::slice::IterMut;
use std::str::Utf8Error;

use crate::array_iterators::{NotNullArrayIter, NullableValuesIterator};

/// Error returned when failing to read a particular batch of data
#[derive(Debug, Error, PartialEq)]
pub enum DeserializationError {
    /// Expected to parse a structure from the ORC file, but the given column is of
    /// an incompatible type. Contains the ORC exception whiched occured when casting.
    #[error("Mismatched ORC column type: {0}")]
    MismatchedColumnKind(String),
    /// The structure has a field which was not selected when reading the ORC file (or
    /// is missing from the file).
    /// Contains the name of the field.
    #[error("Field {0} is missing from ORC file")]
    MissingField(String),
    /// u64 could not be converted to usize. Contains the original error
    #[error("Number of items exceeds maximum buffer capacity on this platform: {0}")]
    UsizeOverflow(TryFromIntError),
    /// Failed to decode a [`String`] (use [`Vec<u8>`](`Vec`) instead for columns of
    /// `binary` type).
    #[error("Failed to decode ORC byte string as UTF-8: {0}")]
    Utf8Error(Utf8Error),
    /// [`read_from_vector_batch`](OrcDeserialize::read_from_vector_batch) or
    /// [`from_vector_batch`](OrcDeserialize::from_vector_batch) orwas called
    /// as a method on a non-`Option` type, with a column containing nulls as parameter.
    ///
    /// Contains a human-readable error.
    #[error("Unexpected null value in ORC file: {0}")]
    UnexpectedNull(String),
    /// [`read_from_vector_batch`](OrcDeserialize::read_from_vector_batch) was given
    /// a `src` column batch longer than its a `dst` vector.
    #[error("Tried to deserialize {src}-long buffer into {dst}-long buffer")]
    MismatchedLength { src: usize, dst: usize },
}

fn check_datatype_equals(
    got_datatype: &DataType,
    expected_datatypes: &[DataType],
    type_name: &str,
) -> Result<(), String> {
    if expected_datatypes.contains(got_datatype) {
        Ok(())
    } else {
        Err(format!(
            "{} must be decoded from Arrow {}, not Arrow {:?}",
            type_name,
            expected_datatypes
                .iter()
                .map(|k| format!("{:?}", k))
                .collect::<Vec<_>>()
                .join("/"),
            got_datatype
        ))
    }
}

/// Types which provide a static `check_datatype` method to ensure ORC files can be
/// deserialized into them.
pub trait CheckableKind {
    /// Returns whether the type can be deserialized from [`RowReader`](::reader::RowReader)
    /// instances with this [selected_kind](::reader::RowReader::selected_kind).
    ///
    /// This should be called before any method provided by [`OrcDeserialize`],
    /// to get errors early and with a human-readable error message instead of cast errors
    /// or deserialization into incorrect types (eg. if a file has two fields swapped).
    fn check_datatype(datatype: &DataType) -> Result<(), String>;

    /// Wrapper for [`check_datatype`]
    fn check_schema(schema: &Schema) -> Result<(), String> {
        Self::check_datatype(&DataType::Struct(schema.fields().clone()))
    }
}

// Needed because most structs are going to have Option as fields, and code generated by
// ar_row_derive needs to call check_datatype on them recursively.
// This avoid needing to dig into the AST to extract the inner type of the Option.
impl<T: CheckableKind> CheckableKind for Option<T> {
    fn check_datatype(datatype: &DataType) -> Result<(), String> {
        T::check_datatype(datatype)
    }
}

/// Types which provide a static `columns` method, which returns the names of all
/// ORC columns the struct expects to read from.
///
/// Nested field names are separated by dots.
///
/// For scalars, this method simply returns the prefix.
pub trait OrcStruct {
    fn columns() -> Vec<String> {
        Self::columns_with_prefix("")
    }

    fn columns_with_prefix(prefix: &str) -> Vec<String>;
}

impl<T: OrcStruct> OrcStruct for Option<T> {
    fn columns_with_prefix(prefix: &str) -> Vec<String> {
        T::columns_with_prefix(prefix)
    }
}

/// Types which can be read in batch from ORC columns ([`Array`]).
pub trait OrcDeserialize: Sized + Default + CheckableKind {
    /// Reads from a [`Array`] to a structure that behaves like
    /// a rewindable iterator of `&mut Self`, and returns the number of rows written.
    ///
    /// If the number of rows written is strictly smaller than `dst`'s size, then
    /// **elements at the end of the `dst` are left unchanged**.
    ///
    /// Users should call
    /// [`check_datatype(row_reader.selected_kind()).unwrap()`](CheckableKind::check_kind)
    /// before calling this function on batches produces by a `row_reader`.
    fn read_from_vector_batch<'a, 'b, T>(
        src: (impl Array + AsArray),
        dst: &'b mut T,
    ) -> Result<usize, DeserializationError>
    where
        Self: 'a,
        &'b mut T: DeserializationTarget<'a, Item = Self> + 'b;

    /// Wrapper for [`read_from_vector_batch`]
    fn read_from_record_batch<'a, 'b, T>(
        src: RecordBatch,
        dst: &'b mut T,
    ) -> Result<usize, DeserializationError>
    where
        Self: 'a,
        &'b mut T: DeserializationTarget<'a, Item = Self> + 'b,
    {
        /// Type helper
        fn f(a: Arc<dyn Array>) -> Arc<dyn Array> {
            a
        }
        let array: StructArray = src.into();
        Self::read_from_vector_batch(f(Arc::new(array)), dst)
    }

    /// Reads from a [`Array`] and returns a `Vec<Option<Self>>`
    ///
    /// Users should call
    /// [`check_datatype(row_reader.selected_kind()).unwrap()`](CheckableKind::check_kind)
    /// before calling this function on batches produces by a `row_reader`.
    ///
    /// This is a wrapper for
    /// [`read_from_vector_batch`](OrcDeserialize::read_from_vector_batch)
    /// which takes care of allocating a buffer, and returns it.
    fn from_vector_batch(
        vector_batch: (impl Array + AsArray),
    ) -> Result<Vec<Self>, DeserializationError> {
        let num_elements = vector_batch.len();
        let mut values = Vec::with_capacity(num_elements);
        values.resize_with(num_elements, Default::default);
        Self::read_from_vector_batch(vector_batch, &mut values)?;
        Ok(values)
    }

    /// Wrapper for [`from_vector_batch`]
    fn from_record_batch(record_batch: RecordBatch) -> Result<Vec<Self>, DeserializationError> {
        /// Type helper
        fn f(a: Arc<dyn Array>) -> Arc<dyn Array> {
            a
        }
        let array: StructArray = record_batch.into();
        Self::from_vector_batch(f(Arc::new(array)))
    }
}

macro_rules! impl_scalar {
    ($ty:ty, $datatype:expr, $method:ident, $array_ty:ty) => {
        impl_scalar!($ty, $datatype, $method, $array_ty, |s| Ok(s));
    };
    ($ty:ty, $datatype:expr, $method:ident, $array_ty:ty, $cast:expr) => {
        impl OrcStruct for $ty {
            fn columns_with_prefix(prefix: &str) -> Vec<String> {
                vec![prefix.to_string()]
            }
        }

        impl CheckableKind for $ty {
            fn check_datatype(datatype: &DataType) -> Result<(), String> {
                check_datatype_equals(datatype, &$datatype, stringify!($ty))
            }
        }

        impl OrcDeserialize for $ty {
            fn read_from_vector_batch<'a, 'b, T>(
                src: (impl Array + AsArray),
                mut dst: &'b mut T,
            ) -> Result<usize, DeserializationError>
            where
                &'b mut T: DeserializationTarget<'a, Item = Self> + 'b,
            {
                let src: &$array_ty = src.$method().ok_or_else(|| {
                    DeserializationError::MismatchedColumnKind(format!(
                        "Could not cast {:?} array with {}",
                        src.data_type(),
                        stringify!($method)
                    ))
                })?;
                match NotNullArrayIter::new(src) {
                    None => Err(DeserializationError::UnexpectedNull(format!(
                        "{} column contains nulls",
                        stringify!($ty)
                    ))),
                    Some(it) => {
                        for (s, d) in it.zip(dst.iter_mut()) {
                            *d = ($cast)(s)?
                        }

                        Ok(src.len())
                    }
                }
            }
        }

        impl OrcDeserialize for Option<$ty> {
            fn read_from_vector_batch<'a, 'b, T>(
                src: (impl Array + AsArray),
                mut dst: &'b mut T,
            ) -> Result<usize, DeserializationError>
            where
                &'b mut T: DeserializationTarget<'a, Item = Self> + 'b,
            {
                let src: &$array_ty = src.$method().ok_or_else(|| {
                    DeserializationError::MismatchedColumnKind(format!(
                        "Could not cast {:?} array with {}",
                        src.data_type(),
                        stringify!($method)
                    ))
                })?;
                for (s, d) in src.iter().zip(dst.iter_mut()) {
                    match s {
                        None => *d = None,
                        Some(s) => *d = Some(($cast)(s)?),
                    }
                }

                Ok(src.len())
            }
        }
    };
}

impl_scalar!(bool, [DataType::Boolean], as_boolean_opt, BooleanArray);
impl_scalar!(
    i8,
    [DataType::Int8],
    as_primitive_opt,
    PrimitiveArray<Int8Type>
);
impl_scalar!(
    i16,
    [DataType::Int16],
    as_primitive_opt,
    PrimitiveArray<Int16Type>
);
impl_scalar!(
    i32,
    [DataType::Int32],
    as_primitive_opt,
    PrimitiveArray<Int32Type>
);
impl_scalar!(
    i64,
    [DataType::Int64],
    as_primitive_opt,
    PrimitiveArray<Int64Type>
);
impl_scalar!(
    u8,
    [DataType::UInt8],
    as_primitive_opt,
    PrimitiveArray<UInt8Type>
);
impl_scalar!(
    u16,
    [DataType::UInt16],
    as_primitive_opt,
    PrimitiveArray<UInt16Type>
);
impl_scalar!(
    u32,
    [DataType::UInt32],
    as_primitive_opt,
    PrimitiveArray<UInt32Type>
);
impl_scalar!(
    u64,
    [DataType::UInt64],
    as_primitive_opt,
    PrimitiveArray<UInt64Type>
);
impl_scalar!(
    f32,
    [DataType::Float32],
    as_primitive_opt,
    PrimitiveArray<Float32Type>
);
impl_scalar!(
    f64,
    [DataType::Float64],
    as_primitive_opt,
    PrimitiveArray<Float64Type>
);
impl_scalar!(
    String,
    [DataType::Utf8, DataType::LargeUtf8],
    as_string_opt,
    StringArray,
    |s: &str| Ok(s.to_owned())
);
impl_scalar!(
    Box<[u8]>,
    [DataType::Binary, DataType::LargeBinary],
    as_binary_opt,
    BinaryArray,
    |s: &[u8]| Ok(s.into())
);

/* TODO timestamps, decimals
impl_scalar!(
    crate::Timestamp,
    [Kind::Timestamp],
    try_into_timestamps,
    |s: (i64, i64)| Ok(crate::Timestamp {
        seconds: s.0,
        nanoseconds: s.1
    })
);

impl OrcStruct for Decimal {
    fn columns_with_prefix(prefix: &str) -> Vec<String> {
        vec![prefix.to_string()]
    }
}

impl CheckableKind for Decimal {
    fn check_datatype(datatype: &DataType) -> Result<(), String> {
        match datatype {
            DataType::Decimal { .. } => Ok(()),
            _ => Err(format!(
                "Decimal must be decoded from ORC Decimal, not ORC {:?}",
                datatype
            )),
        }
    }
}

impl OrcDeserialize for Decimal {
    fn read_from_vector_batch<'a, 'b, T>(
        src: &(impl Array + AsArray),
        mut dst: &'b mut T,
    ) -> Result<usize, DeserializationError>
    where
        &'b mut T: DeserializationTarget<'a, Item = Self> + 'b,
    {
        match src.try_into_decimals64() {
            Ok(src) => match NotNullArrayIter::new(src) {
                None => {
                    return Err(DeserializationError::UnexpectedNull(
                        "Decimal column contains nulls".to_string(),
                    ))
                }
                Some(it) => {
                    for (s, d) in it.zip(dst.iter_mut()) {
                        *d = s;
                    }
                }
            },
            Err(_) => {
                let src = src
                    .try_into_decimals128()
                    .map_err(DeserializationError::MismatchedColumnKind)?;
                match NotNullArrayIter::new(src) {
                    None => {
                        return Err(DeserializationError::UnexpectedNull(
                            "Decimal column contains nulls".to_string(),
                        ))
                    }
                    Some(it) => {
                        for (s, d) in it.zip(dst.iter_mut()) {
                            *d = s;
                        }
                    }
                }
            }
        }

        Ok(src.num_elements().try_into().unwrap())
    }
}

impl OrcDeserialize for Option<Decimal> {
    fn read_from_vector_batch<'a, 'b, T>(
        src: &(impl Array + AsArray),
        mut dst: &'b mut T,
    ) -> Result<usize, DeserializationError>
    where
        &'b mut T: DeserializationTarget<'a, Item = Self> + 'b,
    {
        match src.try_into_decimals64() {
            Ok(src) => {
                for (s, d) in src.iter().zip(dst.iter_mut()) {
                    match s {
                        None => *d = None,
                        Some(s) => *d = Some(s),
                    }
                }
            }
            Err(_) => {
                let src = src
                    .try_into_decimals128()
                    .map_err(DeserializationError::MismatchedColumnKind)?;
                for (s, d) in src.iter().zip(dst.iter_mut()) {
                    match s {
                        None => *d = None,
                        Some(s) => *d = Some(s),
                    }
                }
            }
        }

        Ok(src.num_elements().try_into().unwrap())
    }
}
*/

impl<T: OrcStruct> OrcStruct for Vec<T> {
    fn columns_with_prefix(prefix: &str) -> Vec<String> {
        T::columns_with_prefix(prefix)
    }
}

impl<T: CheckableKind> CheckableKind for Vec<T> {
    fn check_datatype(datatype: &DataType) -> Result<(), String> {
        match datatype {
            DataType::List(inner) => T::check_datatype(inner.data_type()),
            _ => Err(format!("Must be a List, not {:?}", datatype)),
        }
    }
}

/// Shared initialization code of `impl<I> OrcDeserializeOption for Vec<I>`
/// and impl<I> OrcDeserialize for Vec<I>
macro_rules! init_list_read {
    ($src:expr, $dst: expr) => {{
        let src = $src;

        let values: &Arc<_> = src.values();
        let num_elements = values.len();

        // Deserialize the inner elements recursively into this temporary buffer.
        // TODO: write them directly to the final location to avoid a copy
        let mut elements = Vec::new();
        elements.resize_with(num_elements, Default::default);
        OrcDeserialize::read_from_vector_batch::<Vec<I>>(values.clone(), &mut elements)?;

        let elements = elements.into_iter();

        (src, elements)
    }};
}

/// Shared loop code of `impl<I> OrcDeserializeOption for Vec<I>`
/// and impl<I> OrcDeserialize for Vec<I>
macro_rules! build_list_item {
    ($offset:expr, $previous_offset:expr, $elements:expr) => {{
        // Safe because offset is bounded by num_elements;
        let range = ($previous_offset as usize)..($offset as usize);
        let mut array: Vec<I> = Vec::with_capacity(range.len());
        for _ in range {
            match $elements.next() {
                Some(item) => {
                    array.push(item);
                }
                None => panic!(
                    "List too short (expected {} elements, got {})",
                    $offset - $previous_offset,
                    array.len()
                ),
            }
        }
        $previous_offset = $offset;
        array
    }};
}

/// Implementation of [`read_options_from_vector_batch`] generalized over offset type
macro_rules! read_list_of_options_from_vector_batch {
    ($src: expr, $dst: expr) => {{
        let (src, mut elements) = init_list_read!($src, $dst);
        let mut offsets = src.offsets().iter().copied();

        let mut previous_offset = offsets.next().unwrap_or(0);

        let offsets = NullableValuesIterator::new(offsets, src.nulls().map(|nulls| nulls.iter()));
        let num_lists = offsets.len();

        if num_lists > $dst.len() {
            return Err(DeserializationError::MismatchedLength {
                src: num_lists,
                dst: $dst.len(),
            });
        }

        let mut dst = $dst.iter_mut();

        for offset in offsets {
            // Safe because we checked dst.len() == num_elements, and num_elements
            // is also the size of offsets
            let dst_item: &mut Option<Vec<I>> = unsafe { dst.next().unwrap_unchecked() };
            match offset {
                None => *dst_item = None,
                Some(offset) => {
                    *dst_item = Some(build_list_item!(offset, previous_offset, elements));
                }
            }
        }
        if elements.next().is_some() {
            panic!("List too long");
        }

        Ok(num_lists)
    }}
}

/// Deserialization of ORC lists with nullable values
///
/// cannot do `impl<I> OrcDeserialize for Option<Vec<Option<I>>>` because it causes
/// infinite recursion in the type-checker due to this other implementation being
/// available: `impl<I: OrcDeserializeOption> OrcDeserialize for Option<I>`.
impl<I> OrcDeserializeOption for Vec<I>
where
    I: Default + OrcDeserialize,
{
    fn read_options_from_vector_batch<'a, 'b, T>(
        src: (impl Array + AsArray),
        mut dst: &'b mut T,
    ) -> Result<usize, DeserializationError>
    where
        &'b mut T: DeserializationTarget<'a, Item = Option<Self>> + 'b,
    {
        match src.as_list_opt::<i32>() {
            Some(typed_src) => read_list_of_options_from_vector_batch!(typed_src, dst),
            None => {
                let typed_src = src.as_list_opt::<i64>().ok_or_else(|| {
                    DeserializationError::MismatchedColumnKind(format!(
                        "Could not cast {:?} array with as_list_opt",
                        src.data_type()
                    ))
                })?;
                read_list_of_options_from_vector_batch!(typed_src, dst)
            }
        }
    }
}

/// Implementation of [`read_from_vector_batch`] generalized over offset type
macro_rules! read_list_from_vector_batch {
    ($src: expr, $dst: expr) => {{
        let (src, mut elements) = init_list_read!($src, $dst);
        match src.nulls() {
            Some(_) => Err(DeserializationError::UnexpectedNull(format!(
                "{} column contains nulls",
                stringify!($ty)
            ))),
            None=> {


                let mut offsets = src.offsets().iter().copied();

                let mut previous_offset = offsets.next().unwrap_or(0);
                let num_lists = offsets.len();

                if num_lists > $dst.len() {
                    return Err(DeserializationError::MismatchedLength {
                        src: num_lists,
                        dst: $dst.len(),
                    });
                }

                let mut dst = $dst.iter_mut();

                for offset in offsets {
                    // Safe because we checked dst.len() == num_elements, and num_elements
                    // is also the size of offsets
                    let dst_item: &mut Vec<I> = unsafe { dst.next().unwrap_unchecked() };

                    *dst_item = build_list_item!(offset, previous_offset, elements);
                }
                if elements.next().is_some() {
                    panic!("List too long");
                }

                Ok(num_lists)
            }
        }
    }}
}

/// Deserialization of ORC lists without nullable values
impl<I> OrcDeserialize for Vec<I>
where
    I: OrcDeserialize,
{
    fn read_from_vector_batch<'a, 'b, T>(
        src: (impl Array + AsArray),
        mut dst: &'b mut T,
    ) -> Result<usize, DeserializationError>
    where
        &'b mut T: DeserializationTarget<'a, Item = Self> + 'b,
    {
        match src.as_list_opt::<i32>() {
            Some(typed_src) => read_list_from_vector_batch!(typed_src, dst),
            None => {
                let typed_src = src.as_list_opt::<i64>().ok_or_else(|| {
                    DeserializationError::MismatchedColumnKind(format!(
                        "Could not cast {:?} array with as_list_opt",
                        src.data_type()
                    ))
                })?;
                read_list_from_vector_batch!(typed_src, dst)
            }
        }
    }
}

/// The trait of things that can have ORC data written to them.
///
/// It must be (mutably) iterable, exact-size, and iterable multiple times (one for
/// each column it contains).
///
/// # Safety
///
/// Implementations returning `len()` values larger than the
/// actual length of the iterator returned by `iter_mut()` would lead to
/// undefined behavior (values yielded by the iterator are unwrapped unsafely,
/// for performance).
pub unsafe trait DeserializationTarget<'a> {
    type Item: 'a;
    type IterMut<'b>: Iterator<Item = &'b mut Self::Item>
    where
        Self: 'b,
        'a: 'b;

    fn len(&self) -> usize;
    fn iter_mut(&mut self) -> Self::IterMut<'_>;

    fn is_empty(&self) -> bool {
        self.len() == 0
    }

    fn map<B, F>(&mut self, f: F) -> MultiMap<Self, F>
    where
        Self: Sized,
        F: FnMut(&mut Self::Item) -> &mut B,
    {
        MultiMap { iter: self, f }
    }
}

unsafe impl<'a, V: Sized + 'a> DeserializationTarget<'a> for &mut Vec<V> {
    type Item = V;
    type IterMut<'b> = IterMut<'b, V> where V: 'b, 'a: 'b, Self: 'b;

    fn len(&self) -> usize {
        (self as &Vec<_>).len()
    }

    fn iter_mut(&mut self) -> IterMut<'_, V> {
        <[_]>::iter_mut(self)
    }
}

/// A map that can be iterated multiple times
pub struct MultiMap<'c, T: Sized, F> {
    iter: &'c mut T,
    f: F,
}

unsafe impl<'a, 'c, V: Sized + 'a, V2: Sized + 'a, T, F> DeserializationTarget<'a>
    for &mut MultiMap<'c, T, F>
where
    F: Copy + for<'b> FnMut(&'b mut V) -> &'b mut V2,
    T: DeserializationTarget<'a, Item = V>,
{
    type Item = V2;
    type IterMut<'b> = Map<T::IterMut<'b>, F> where T: 'b, 'a: 'b, F: 'b, Self: 'b;

    fn len(&self) -> usize {
        self.iter.len()
    }

    fn iter_mut(&mut self) -> Map<T::IterMut<'_>, F> {
        self.iter.iter_mut().map(self.f)
    }
}

/// Given a [`StructArray`], returns a vector of structures initialized with
/// [`Default`] for every not-null value in the [`StructArray`], and `None` for
/// null values.
pub fn default_option_vec<T: Default>(vector_batch: &StructArray) -> Vec<Option<T>> {
    match vector_batch.nulls() {
        None => (0..vector_batch.len())
            .map(|_| Some(Default::default()))
            .collect(),
        Some(nulls) => nulls
            .iter()
            .map(|b| if b { None } else { Some(Default::default()) })
            .collect(),
    }
}

/// Internal trait to allow implementing OrcDeserialize on `Option<T>` where `T` is
/// a structure defined in other crates
pub trait OrcDeserializeOption: Sized + CheckableKind {
    /// Reads from a [`Array`] to a structure that behaves like
    /// a rewindable iterator of `&mut Option<Self>`.
    fn read_options_from_vector_batch<'a, 'b, T>(
        src: (impl Array + AsArray),
        dst: &'b mut T,
    ) -> Result<usize, DeserializationError>
    where
        Self: 'a,
        &'b mut T: DeserializationTarget<'a, Item = Option<Self>> + 'b;
}

impl<I: OrcDeserializeOption> OrcDeserialize for Option<I> {
    fn read_from_vector_batch<'a, 'b, T>(
        src: (impl Array + AsArray),
        dst: &'b mut T,
    ) -> Result<usize, DeserializationError>
    where
        &'b mut T: DeserializationTarget<'a, Item = Self> + 'b,
        I: 'a,
    {
        I::read_options_from_vector_batch(src, dst)
    }
}

#[cfg(test)]
mod tests {
    use arrow::datatypes::DataType;

    use super::*;

    #[test]
    fn test_map_struct() {
        // TODO: for now this test only makes sure the code compiles, but it should
        // actually run it eventually.
        #[derive(Default)]
        struct Test {
            field1: Option<i64>,
        }

        impl CheckableKind for Test {
            fn check_datatype(datatype: &DataType) -> Result<(), String> {
                check_datatype_equals(
                    datatype,
                    &[DataType::Struct(
                        vec![Field::new("field1", DataType::Int64, true)].into(),
                    )],
                    "Vec<u8>",
                )
            }
        }

        impl OrcDeserialize for Option<Test> {
            fn read_from_vector_batch<'a, 'b, T>(
                src: (impl Array + AsArray),
                mut dst: &'b mut T,
            ) -> Result<usize, DeserializationError>
            where
                &'b mut T: DeserializationTarget<'a, Item = Self>,
            {
                let src = src.as_struct_opt().ok_or_else(|| {
                    DeserializationError::MismatchedColumnKind(format!(
                        "Could not cast {:?} array with as_struct_opt",
                        src.data_type()
                    ))
                })?;
                let columns = src.columns();
                let column = columns.into_iter().next().unwrap();
                OrcDeserialize::read_from_vector_batch::<MultiMap<&mut T, _>>(
                    column.clone(),
                    &mut dst.map(|struct_| &mut struct_.as_mut().unwrap().field1),
                )?;

                Ok(src.len())
            }
        }
    }

    #[test]
    fn test_check_datatype() {
        assert_eq!(i64::check_datatype(&DataType::Int64), Ok(()));
        // TODO timestamps: assert_eq!(crate::Timestamp::check_datatype(&DataType::Timestamp(TimeUnit::Nanosecond, None)), Ok(()));
        assert_eq!(String::check_datatype(&DataType::Utf8), Ok(()));
        assert_eq!(String::check_datatype(&DataType::LargeUtf8), Ok(()));
        assert_eq!(Box::<[u8]>::check_datatype(&DataType::Binary), Ok(()));
        assert_eq!(Box::<[u8]>::check_datatype(&DataType::LargeBinary), Ok(()));
    }

    #[test]
    fn test_check_datatype_fail() {
        assert_eq!(
            i64::check_datatype(&DataType::Utf8),
            Err("i64 must be decoded from Arrow Int64, not Arrow Utf8".to_string())
        );
        assert_eq!(
            i64::check_datatype(&DataType::Int32),
            Err("i64 must be decoded from Arrow Int64, not Arrow Int32".to_string())
        );
        assert_eq!(
            String::check_datatype(&DataType::Int32),
            Err("String must be decoded from Arrow Utf8/LargeUtf8, not Arrow Int32".to_string())
        );
        assert_eq!(
            String::check_datatype(&DataType::Binary),
            Err("String must be decoded from Arrow Utf8/LargeUtf8, not Arrow Binary".to_string())
        );
        assert_eq!(
            Box::<[u8]>::check_datatype(&DataType::Int32),
            Err(
                "Box<[u8]> must be decoded from Arrow Binary/LargeBinary, not Arrow Int32"
                    .to_string()
            )
        );
        assert_eq!(
            Box::<[u8]>::check_datatype(&DataType::Utf8),
            Err(
                "Box<[u8]> must be decoded from Arrow Binary/LargeBinary, not Arrow Utf8"
                    .to_string()
            )
        );
    }
}
